
<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ctext y='0.9em' font-size='90'%3EğŸ§ª%3C/text%3E%3C/svg%3E">
    <title>Eagle Cycling Infinite Loop Demo(Eagle Voxel Run)</title>
    <script src="layout2.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
        #ui {
            position: absolute;
            top: 20px;
            left: 0;
            width: 100%;
            text-align: center;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            pointer-events: none;
            text-shadow: 2px 2px 0 #000;
        }
        h1 { margin: 0; font-size: 24px; }
        p { margin: 5px 0 0; font-size: 14px; opacity: 0.8; }
    </style>
</head>
<body>

    <div id="ui">
        <h1>Voxel Eagle: Endless Road Ride</h1>
        <p>Drag to rotate the view | Scroll to zoom</p>
    </div>

    <script type="module" nonce="MjkyODY2MDg4NiwxMTYzMTcwNjgz">
        import * as THREE from 'https://esm.sh/three@0.158.0';
        import { OrbitControls } from 'https://esm.sh/three@0.158.0/examples/jsm/controls/OrbitControls.js';

        // ==========================================
        // 1. åŸºç¡€åœºæ™¯è®¾ç½®
        // ==========================================
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); // è“å¤©
        scene.fog = new THREE.Fog(0x87CEEB, 20, 60); // è¿œå¤„é›¾æ°”ï¼Œéšè—å…¬è·¯å°½å¤´

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(20, 15, 20);
        camera.lookAt(0, 2, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.target.set(0, 3, 0);

        // ç¯å…‰
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
        dirLight.position.set(20, 40, 20);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.camera.near = 0.5;
        dirLight.shadow.camera.far = 100;
        dirLight.shadow.camera.left = -20;
        dirLight.shadow.camera.right = 20;
        dirLight.shadow.camera.top = 20;
        dirLight.shadow.camera.bottom = -20;
        scene.add(dirLight);

        // ==========================================
        // 2. ä½“ç´ æ„å»ºå·¥å…·
        // ==========================================
        const boxGeo = new THREE.BoxGeometry(1, 1, 1);
        const edgeGeo = new THREE.EdgesGeometry(boxGeo);
        const lineMat = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 });

        // æè´¨ç¼“å­˜ï¼Œä¼˜åŒ–æ€§èƒ½
        const materials = {};
        function getMaterial(colorHex) {
            if (!materials[colorHex]) {
                materials[colorHex] = new THREE.MeshLambertMaterial({ color: colorHex });
            }
            return materials[colorHex];
        }

        // åˆ›å»ºå•ä¸ªä½“ç´ å¹¶åŠ å…¥åˆ°æŒ‡å®šçš„ Group ä¸­
        function createVoxel(group, x, y, z, colorHex) {
            const mesh = new THREE.Mesh(boxGeo, getMaterial(colorHex));
            mesh.position.set(x, y, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            const edges = new THREE.LineSegments(edgeGeo, lineMat);
            mesh.add(edges);
            
            group.add(mesh);
            return mesh;
        }

        // ç»˜åˆ¶å—çŠ¶åŒºåŸŸ
        function drawBlock(group, startX, startY, startZ, w, h, d, color) {
            for(let x=0; x<w; x++) {
                for(let y=0; y<h; y++) {
                    for(let z=0; z<d; z++) {
                        createVoxel(group, startX + x, startY + y, startZ + z, color);
                    }
                }
            }
        }

        // ==========================================
        // 3. ç»„è£…è€é¹°å’Œä¸‰è½®è½¦ (åˆ†å±‚çº§ä»¥ä¾¿åŠ¨ç”»)
        // ==========================================
        
        const playerGroup = new THREE.Group();
        scene.add(playerGroup);

        // 3.1 è½¦è½®ç»„ (éœ€è¦æ—‹è½¬)
        const frontWheelGroup = new THREE.Group();
        const backWheelGroup = new THREE.Group(); // åŒ…å«å·¦å³åè½®
        
        // é¢œè‰²å®šä¹‰
        const C = {
            TIRE: 0x333333, RIM: 0xDDDDDD, FRAME: 0xD62828, SEAT: 0x111111,
            BROWN: 0x5C4033, WHITE: 0xFFFFFF, BEAK: 0xFCBF49, EYE: 0x000000
        };

        // --- å‰è½® ---
        // æ”¾åœ¨ç»„çš„ä¸­å¿ƒ(0,0,0)ä»¥ä¾¿æ—‹è½¬ï¼Œä¹‹åç§»åŠ¨æ•´ä¸ªç»„
        drawBlock(frontWheelGroup, -1, -2, -2, 2, 4, 4, C.TIRE); // è½®
        createVoxel(frontWheelGroup, -1.1, 0, 0, C.RIM); 
        createVoxel(frontWheelGroup, 1.1, 0, 0, C.RIM);
        
        frontWheelGroup.position.set(0, 2, -5); // ç§»åŠ¨åˆ°è½¦å¤´ä½ç½®
        playerGroup.add(frontWheelGroup);

        // --- åè½® ---
        // å·¦åè½®
        drawBlock(backWheelGroup, -3.5, -1.5, -1.5, 1, 3, 3, C.TIRE);
        createVoxel(backWheelGroup, -3.6, 0, 0, C.RIM);
        // å³åè½®
        drawBlock(backWheelGroup, 2.5, -1.5, -1.5, 1, 3, 3, C.TIRE);
        createVoxel(backWheelGroup, 2.6, 0, 0, C.RIM);

        backWheelGroup.position.set(0, 1.5, 2.5); // ç§»åŠ¨åˆ°è½¦å°¾ä½ç½®
        playerGroup.add(backWheelGroup);

        // 3.2 è½¦æ¶ä¸èº«ä½“ (ä¸æ—‹è½¬ï¼Œåªéšæ•´ä½“é¢ ç°¸)
        const bodyGroup = new THREE.Group();
        playerGroup.add(bodyGroup);

        // è½¦æ¶
        drawBlock(bodyGroup, -2, 1, 2.5, 4, 1, 1, C.FRAME); // åè½´
        drawBlock(bodyGroup, -0.5, 1, -3, 1, 1, 6, C.FRAME); // ä¸»æ¢
        drawBlock(bodyGroup, -0.5, 2, 1, 1, 2, 1, C.FRAME); // åº§æ¤…æŸ±
        drawBlock(bodyGroup, -1.5, 3, 0, 3, 1, 3, C.SEAT); // åº§å«
        
        // å‰å‰ (è¿æ¥å‰è½®)
        drawBlock(bodyGroup, -1.2, 2, -5, 0.2, 3, 1, C.FRAME); // å·¦å‰
        drawBlock(bodyGroup, 1, 2, -5, 0.2, 3, 1, C.FRAME);  // å³å‰
        drawBlock(bodyGroup, -2.5, 5, -5, 5, 0.5, 0.5, 0xC0C0C0); // è½¦æŠŠæ‰‹

        // è€é¹°è…¿ (ç®€åŒ–ä¸ºé™æ€ï¼Œç¨å¾®å‘å‰)
        drawBlock(bodyGroup, -1.5, 2, -2, 1, 2, 1, C.BEAK);
        drawBlock(bodyGroup, 0.5, 2, -2, 1, 2, 1, C.BEAK);

        // è€é¹°èº«ä½“
        drawBlock(bodyGroup, -2, 4, 0, 4, 4, 4, C.BROWN);
        
        // ç¿…è†€
        drawBlock(bodyGroup, -4, 5, 1, 2, 1, 2, C.BROWN);
        drawBlock(bodyGroup, 2, 5, 1, 2, 1, 2, C.BROWN);

        // å¤´
        drawBlock(bodyGroup, -1.5, 8, -0.5, 3, 3, 4, C.WHITE);
        
        // è„¸éƒ¨ç»†èŠ‚
        createVoxel(bodyGroup, -1.6, 9, -0.6, C.EYE);
        createVoxel(bodyGroup, 1.6, 9, -0.6, C.EYE);
        drawBlock(bodyGroup, -0.5, 8, -2.5, 1, 2, 2, C.BEAK); // å˜´
        createVoxel(bodyGroup, -0.5, 8, -2.5, C.BEAK); // å‹¾

        // å°¾å·´
        drawBlock(bodyGroup, -1, 4, 4, 2, 1, 2, C.WHITE);


        // ==========================================
        // 4. æ— é™å…¬è·¯ç³»ç»Ÿ
        // ==========================================
        
        // ä½¿ç”¨ Canvas åŠ¨æ€ç”Ÿæˆåƒç´ é£æ ¼çš„é“è·¯çº¹ç†
        function createRoadTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            
            // æ²¥é’è‰²èƒŒæ™¯
            ctx.fillStyle = '#444444';
            ctx.fillRect(0, 0, 128, 128);
            
            // å™ªç‚¹ (æ¨¡æ‹Ÿåƒç´ è·¯é¢)
            ctx.fillStyle = '#555555';
            for(let i=0; i<20; i++) {
                ctx.fillRect(Math.random()*128, Math.random()*128, 4, 4);
            }

            // é»„è‰²è½¦é“çº¿
            ctx.fillStyle = '#FFD700';
            ctx.fillRect(60, 0, 8, 64); // çº¿æ¡åªç”»ä¸ŠåŠéƒ¨åˆ†ï¼Œåˆ©ç”¨Repeatäº§ç”Ÿè™šçº¿æ•ˆæœ

            // è¾¹ç¼˜ç™½çº¿
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(5, 0, 4, 128);
            ctx.fillRect(119, 0, 4, 128);

            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.RepeatWrapping;
            tex.magFilter = THREE.NearestFilter; // ä¿æŒåƒç´ æ„Ÿ
            tex.repeat.set(1, 5); // åœ¨Zè½´æ–¹å‘é‡å¤5æ¬¡
            return tex;
        }

        const roadWidth = 20;
        const roadLength = 200;
        const roadGeo = new THREE.PlaneGeometry(roadWidth, roadLength);
        const roadMat = new THREE.MeshPhongMaterial({ 
            map: createRoadTexture()
        });
        
        const road = new THREE.Mesh(roadGeo, roadMat);
        road.rotation.x = -Math.PI / 2;
        road.position.y = 0;
        road.position.z = 0;
        road.receiveShadow = true;
        scene.add(road);

        // å¢åŠ è·¯è‚©çš„è‰åœ° (ç®€å•çš„ç»¿è‰²å¹³é¢)
        const grassGeo = new THREE.PlaneGeometry(200, 200);
        const grassMat = new THREE.MeshLambertMaterial({ color: 0x4caf50 });
        const grass = new THREE.Mesh(grassGeo, grassMat);
        grass.rotation.x = -Math.PI / 2;
        grass.position.y = -0.1; // ç•¥ä½äºè·¯é¢
        scene.add(grass);

        // ==========================================
        // 5. åŠ¨æ€äº‘æœµç³»ç»Ÿ
        // ==========================================
        const cloudGroup = new THREE.Group();
        scene.add(cloudGroup);

        const clouds = [];
        
        function createCloud(x, y, z) {
            const group = new THREE.Group();
            // ç”Ÿæˆä¸è§„åˆ™çš„äº‘å—
            const size = Math.floor(Math.random() * 3) + 2;
            drawBlock(group, 0, 0, 0, size+1, 1, size, 0xFFFFFF);
            drawBlock(group, 1, 1, 1, size-1, 1, size-1, 0xFFFFFF);
            
            group.position.set(x, y, z);
            cloudGroup.add(group);
            return group;
        }

        // åˆå§‹ç”Ÿæˆ20æœµäº‘
        for(let i=0; i<20; i++) {
            const x = (Math.random() - 0.5) * 60; // å·¦å³æ•£å¸ƒ
            const y = 15 + Math.random() * 10;    // é«˜åº¦
            const z = (Math.random() - 0.5) * 100; // æ·±åº¦æ•£å¸ƒ
            const cloud = createCloud(x, y, z);
            clouds.push({ mesh: cloud, speed: 0.05 + Math.random() * 0.05 });
        }

        // ==========================================
        // 6. åŠ¨ç”»å¾ªç¯
        // ==========================================
        
        let speed = 0.3; // éª‘è¡Œé€Ÿåº¦
        let time = 0;

        function animate() {
            requestAnimationFrame(animate);
            time += 0.1;

            // 1. è½®å­è½¬åŠ¨
            // è½®å­åŠå¾„çº¦ä¸º2ä¸ªå•ä½ï¼Œæ ¹æ®é€Ÿåº¦è®¡ç®—æ—‹è½¬
            frontWheelGroup.rotation.x -= speed * 0.3; 
            backWheelGroup.rotation.x -= speed * 0.3;

            // 2. èº«ä½“èµ·ä¼ (æ¨¡æ‹Ÿéª‘è¡Œç”¨åŠ›)
            playerGroup.position.y = Math.sin(time * 1.5) * 0.1; 
            // èº«ä½“ç¨å¾®å·¦å³æ‘‡æ‘†
            playerGroup.rotation.z = Math.sin(time * 0.5) * 0.02;

            // 3. é“è·¯çº¹ç†åç§» (åˆ¶é€ å‰è¿›çš„é”™è§‰)
            // çº¹ç†çš„Yè½´å¯¹åº”3Dä¸–ç•Œçš„Zè½´
            roadMat.map.offset.y -= (speed * 0.02); 

            // 4. äº‘æœµç§»åŠ¨é€»è¾‘
            clouds.forEach(c => {
                c.mesh.position.z += speed; // äº‘å‘åé£˜
                
                // å¦‚æœäº‘è·‘åˆ°äº†ç›¸æœºåé¢å¤ªè¿œï¼Œé‡ç½®åˆ°å‰æ–¹
                if(c.mesh.position.z > 30) {
                    c.mesh.position.z = -80;
                    c.mesh.position.x = (Math.random() - 0.5) * 60;
                }
            });

            controls.update();
            renderer.render(scene, camera);
        }

        // çª—å£è‡ªé€‚åº”
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>
</html>
```